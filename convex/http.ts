import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";
import { internal } from "./_generated/api";
import { Id } from "./_generated/dataModel";

const http = httpRouter();

// Scopes define the level of access your application is requesting.
// Ensure these scopes match what you configure in your Google Cloud Console.
// Requesting minimal necessary scopes is best practice.
const GOOGLE_SCOPES = [
    "https://www.googleapis.com/auth/userinfo.email", // Get user's email address
    "https://www.googleapis.com/auth/userinfo.profile", // Get user's basic profile info
    // Add Gmail scopes ONLY if you intend to read/send emails
    "https://www.googleapis.com/auth/gmail.send", // Permission to send emails
    // "https://www.googleapis.com/auth/gmail.readonly", // Read emails
    // "https://mail.google.com/" // Read, compose, send, and permanently delete all your email from Gmail
    // Consider more granular scopes if possible: gmail.compose, gmail.send, gmail.modify
];

// Helper function to get environment variables or throw
function getEnvVariable(varName: string): string {
    const value = process.env[varName];
    if (value === undefined) {
        throw new Error(`Required environment variable "${varName}" is not set.`);
    }
    return value;
}

// Action to initiate the Google OAuth flow
const startGoogleOAuth = httpAction(async (ctx, request) => {
    const clientId = getEnvVariable("GOOGLE_CLIENT_ID");
    console.log(`[DEBUG OAuth] GOOGLE_CLIENT_ID: ${clientId}`);
    
    const convexSiteUrl = getEnvVariable("PUBLIC_CONVEX_URL");
    console.log(`[DEBUG OAuth] PUBLIC_CONVEX_URL raw value: "${convexSiteUrl}"`);
    
    // Ensure URL has no trailing slash before adding path
    const baseUrl = convexSiteUrl.endsWith('/') ? convexSiteUrl.slice(0, -1) : convexSiteUrl;
    console.log(`[DEBUG OAuth] Normalized base URL: "${baseUrl}"`);
    
    const redirectUri = `${baseUrl}/handleGoogleCallback`;
    console.log(`[DEBUG OAuth] Constructed redirectUri: "${redirectUri}"`);
    
    // --- Generate and store state --- 
    // NOTE: HTTP actions don't have user auth context directly.
    // The *frontend* needs to call a standard mutation (generateOAuthState)
    // BEFORE redirecting to this HTTP action URL, passing the state value.
    // This action should ideally *receive* the pre-generated state.
    // Modifying the flow for simplicity for now:
    // Let's assume the state is passed as a query param TO this action.
    // This isn't ideal security-wise, as the user isn't validated here.
    // A better approach involves the frontend calling the mutation first.
    
    // --- TEMPORARY WORKAROUND (Less Secure) ---
    // Ideally, state is generated by a *mutation* called by the *authenticated user*
    // and passed to this endpoint, NOT generated here without auth.
    const url = new URL(request.url);
    const state = url.searchParams.get("state"); // Expect state from frontend redirect
    if (!state) {
        console.error("Missing state parameter in startGoogleOAuth request.");
        return new Response("Missing state parameter", { status: 400 });
    }
    // -------------------------------------

    const authUrl = new URL("https://accounts.google.com/o/oauth2/v2/auth");
    authUrl.searchParams.set("client_id", clientId);
    authUrl.searchParams.set("redirect_uri", redirectUri);
    authUrl.searchParams.set("response_type", "code");
    authUrl.searchParams.set("scope", GOOGLE_SCOPES.join(" "));
    authUrl.searchParams.set("access_type", "offline"); // Request refresh token
    authUrl.searchParams.set("prompt", "consent"); // Force consent screen for refresh token
    // Include the state parameter received from the frontend
    authUrl.searchParams.set("state", state);

    console.log(`[DEBUG OAuth] Final auth URL params:`);
    for (const [key, value] of authUrl.searchParams.entries()) {
        console.log(`[DEBUG OAuth]   ${key}: ${value}`);
    }
    console.log(`[DEBUG OAuth] Full Google auth URL: ${authUrl.toString()}`);
    
    console.log(`Redirecting user to Google OAuth URL with state: ${state}`);
    return new Response(null, { 
        status: 302,
        headers: { Location: authUrl.toString() },
    });
});

// Action to handle the callback from Google after user authorization
const handleGoogleCallback = httpAction(async (ctx, request) => {
    const clientId = getEnvVariable("GOOGLE_CLIENT_ID");
    const clientSecret = getEnvVariable("GOOGLE_CLIENT_SECRET");
    const appUrl = getEnvVariable("APP_URL"); // Your frontend app URL
    const convexSiteUrl = getEnvVariable("PUBLIC_CONVEX_URL"); 
    console.log(`[DEBUG Callback] PUBLIC_CONVEX_URL raw value: "${convexSiteUrl}"`);
    
    // Ensure URL has no trailing slash before adding path
    const baseUrl = convexSiteUrl.endsWith('/') ? convexSiteUrl.slice(0, -1) : convexSiteUrl;
    console.log(`[DEBUG Callback] Normalized base URL: "${baseUrl}"`);
    
    const redirectUri = `${baseUrl}/handleGoogleCallback`;
    console.log(`[DEBUG Callback] Constructed redirectUri: "${redirectUri}"`);

    const url = new URL(request.url);
    console.log(`[DEBUG Callback] Incoming callback URL: ${request.url}`);
    console.log(`[DEBUG Callback] Request pathname: ${url.pathname}`);
    
    const code = url.searchParams.get("code");
    const error = url.searchParams.get("error");
    const state = url.searchParams.get("state"); // Get state from Google's callback

    console.log(`[DEBUG Callback] URL params: code=${code ? "present" : "missing"}, error=${error || "none"}, state=${state || "missing"}`);

    if (error) {
        console.error(`Google OAuth Error: ${error}`);
        const errorSettingsUrl = `${appUrl}/settings?error=oauth_error&provider=google&message=${encodeURIComponent(error)}`;
        return new Response(null, { status: 302, headers: { Location: errorSettingsUrl }});
    }
    if (!code) {
        // Handle case where user denies access
        console.warn("Authorization code missing. User likely denied access.");
        const deniedSettingsUrl = `${appUrl}/settings?error=access_denied&provider=google`;
        return new Response(null, { status: 302, headers: { Location: deniedSettingsUrl }});
    }
    if (!state) {
        console.error("State parameter missing from Google callback.");
        const errorSettingsUrl = `${appUrl}/settings?error=missing_state&provider=google`;
        return new Response(null, { status: 302, headers: { Location: errorSettingsUrl }});
    }

    let userId: Id<"users"> | null = null;
    try {
        // --- Validate State and Get User ID --- 
        // This mutation validates the state AND deletes it
        userId = await ctx.runMutation(internal.connections.consumeOAuthState, { 
            stateValue: state 
        });
        console.log(`Successfully validated state ${state} for user ${userId}`);

        // --- Exchange Code for Tokens --- 
        const tokenUrl = "https://oauth2.googleapis.com/token";
        console.log(`[DEBUG Callback] Preparing to exchange code for token`);
        console.log(`[DEBUG Callback] Token request params: client_id=${clientId}, redirect_uri=${redirectUri}`);
        
        const tokenResponse = await fetch(tokenUrl, {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({
                code: code,
                client_id: clientId,
                client_secret: clientSecret,
                redirect_uri: redirectUri,
                grant_type: "authorization_code",
            }),
        });

        if (!tokenResponse.ok) {
            const errorBody = await tokenResponse.text();
            console.error(`[DEBUG Callback] Token exchange error: Status ${tokenResponse.status}, Body: ${errorBody}`);
            throw new Error(`Failed to exchange code for token: ${tokenResponse.status} ${errorBody}`);
        }

        const tokenData = await tokenResponse.json();
        const accessToken = tokenData.access_token;
        const refreshToken = tokenData.refresh_token; // Only sent on first authorization
        const grantedScopes = tokenData.scope.split(" ");

        if (!accessToken) {
            throw new Error("Access Token not found in Google response.");
        }
        // IMPORTANT: Handle missing refresh token on subsequent authorizations if needed
        if (!refreshToken) {
             console.warn("Refresh Token not received. User might have already authorized.");
             // TODO: Need a strategy to retrieve/reuse existing refresh token if only updating scopes.
             // This often involves checking existing connections before starting OAuth.
        }

        // --- Get User Info (Email) --- 
        const userInfoUrl = "https://www.googleapis.com/oauth2/v2/userinfo";
        const userInfoResponse = await fetch(userInfoUrl, {
            headers: { Authorization: `Bearer ${accessToken}` },
        });

        if (!userInfoResponse.ok) {
            throw new Error(`Failed to fetch user info: ${userInfoResponse.status}`);
        }
        const userInfo = await userInfoResponse.json();
        const userEmail = userInfo.email;

        if (!userEmail) {
            throw new Error("Could not retrieve email from Google user info.");
        }

        // --- Store Connection in DB (WITH RAW TOKENS - UNSAFE) ---
        console.log(`Storing connection for user ${userId}, email ${userEmail} (Tokens stored UNSAFELY)`);
        await ctx.runMutation(internal.connections.storeOrUpdateGoogleConnection, {
            userId: userId,
            accountEmail: userEmail,
            scopes: grantedScopes,
            // Pass the raw tokens 
            accessToken: accessToken, 
            refreshToken: refreshToken, // Pass even if undefined (optional field)
        });

        // --- Redirect User Back to Frontend (Success) ---
        const settingsUrl = `${appUrl}/settings?success=connection&provider=google`; 
        console.log(`Google OAuth successful for ${userEmail}. Redirecting user ${userId} to ${settingsUrl}`);
        return new Response(null, {
            status: 302,
            headers: { Location: settingsUrl },
        });

    } catch (error: any) {
        console.error("Error in Google OAuth callback:", error);
        // Redirect back to settings with an error parameter
        const errorParam = error.message === "Invalid or expired OAuth state provided." ? "invalid_state" : "oauth_failed";
        const errorSettingsUrl = `${appUrl}/settings?error=${errorParam}&provider=google`;
        return new Response(null, {
            status: 302,
            headers: { Location: errorSettingsUrl },
        });
    }
});

// Define routes
http.route({
    path: "/startGoogleOAuth",
    method: "GET",
    handler: startGoogleOAuth,
});

http.route({
    path: "/handleGoogleCallback",
    method: "GET",
    handler: handleGoogleCallback,
});

// Microsoft routes would be added similarly
// http.route({ path: "/startMicrosoftOAuth", ... });
// http.route({ path: "/handleMicrosoftCallback", ... });

// Mailgun Webhook Endpoint to handle incoming email replies
http.route({
  path: "/emailReplyWebhook",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    console.log("[MAILGUN DEBUG] Received webhook request to /emailReplyWebhook");
    
    // Log request headers
    const headers: Record<string, string> = {};
    request.headers.forEach((value, key) => {
      headers[key] = value;
    });
    console.log("[MAILGUN DEBUG] Request headers:", JSON.stringify(headers));
    
    // Get form data directly - Mailgun sends all verification info in the form data, not headers
    let formData;
    let formDataObj: Record<string, string> = {};
    
    try {
      formData = await request.formData();
      
      // Convert FormData to a plain object
      formData.forEach((value, key) => {
        // Convert all values to strings for simplicity
        formDataObj[key] = typeof value === 'string' ? value : '[BINARY DATA]';
      });
      
      const keysToLog = Object.keys(formDataObj).join(", ");
      console.log(`[MAILGUN DEBUG] Received form data with keys: ${keysToLog}`);
      
      // Log some important values if they exist
      console.log("[MAILGUN DEBUG] Important form fields:");
      const importantFields = ["recipient", "sender", "subject", "body-plain", "stripped-text", "timestamp", "token", "signature"];
      importantFields.forEach(field => {
        if (formDataObj[field]) {
          console.log(`[MAILGUN DEBUG] ${field}: ${field === "body-plain" || field === "stripped-text" 
            ? formDataObj[field].substring(0, 50) + "..." 
            : formDataObj[field]}`);
        }
      });
      
    } catch (e) {
      console.error("[MAILGUN DEBUG] Error parsing form data from Mailgun webhook:", e);
      
      // Try to get the raw body as text as a fallback
      try {
        const clonedRequest = request.clone();
        const bodyText = await clonedRequest.text();
        console.log("[MAILGUN DEBUG] Raw request body (first 500 chars):", bodyText.substring(0, 500));
      } catch (textError) {
        console.error("[MAILGUN DEBUG] Failed to read raw body:", textError);
      }
      
      return new Response("Failed to parse form data", { status: 400 });
    }
    
    // Basic validation - at minimum we need a recipient
    if (!formDataObj.recipient) {
      console.warn("[MAILGUN DEBUG] Missing recipient in form data");
      return new Response("Missing required email fields", { status: 200 });
    }

    try {
      // Call the internal action with the full form data
      console.log("[MAILGUN DEBUG] Calling internal action with form data");
      const result = await ctx.runAction(internal.mailgun.verifyAndProcessWebhook, {
        formData: formDataObj
      });

      console.log("[MAILGUN DEBUG] Internal action result:", JSON.stringify(result));
      // Return response based on the action's outcome
      return new Response(result.message, { status: result.status });

    } catch (error: any) {
      console.error("[MAILGUN DEBUG] Error invoking verifyAndProcessWebhook action:", error);
      // Generic error if the action itself fails unexpectedly
      return new Response("Internal Server Error invoking action", { status: 500 });
    }
  }),
});

// Export the configured router
export default http;

 