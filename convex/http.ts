import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";
import { internal } from "./_generated/api";
import { Id } from "./_generated/dataModel";

const http = httpRouter();

// Scopes define the level of access your application is requesting.
// Ensure these scopes match what you configure in your Google Cloud Console.
// Requesting minimal necessary scopes is best practice.
const GOOGLE_SCOPES = [
    "https://www.googleapis.com/auth/userinfo.email", // Get user's email address
    "https://www.googleapis.com/auth/userinfo.profile", // Get user's basic profile info
    // Add Gmail scopes ONLY if you intend to read/send emails
    "https://www.googleapis.com/auth/gmail.send", // Permission to send emails
    // "https://www.googleapis.com/auth/gmail.readonly", // Read emails
    // "https://mail.google.com/" // Read, compose, send, and permanently delete all your email from Gmail
    // Consider more granular scopes if possible: gmail.compose, gmail.send, gmail.modify
];

// Helper function to get environment variables or throw
function getEnvVariable(varName: string): string {
    const value = process.env[varName];
    if (value === undefined) {
        throw new Error(`Required environment variable "${varName}" is not set.`);
    }
    return value;
}

// Action to initiate the Google OAuth flow
const startGoogleOAuth = httpAction(async (ctx, request) => {
    const clientId = getEnvVariable("GOOGLE_CLIENT_ID");
    const convexSiteUrl = getEnvVariable("PUBLIC_CONVEX_HTTP_URL");
    const redirectUri = `${convexSiteUrl}/handleGoogleCallback`;
    
    // --- Generate and store state --- 
    // NOTE: HTTP actions don't have user auth context directly.
    // The *frontend* needs to call a standard mutation (generateOAuthState)
    // BEFORE redirecting to this HTTP action URL, passing the state value.
    // This action should ideally *receive* the pre-generated state.
    // Modifying the flow for simplicity for now:
    // Let's assume the state is passed as a query param TO this action.
    // This isn't ideal security-wise, as the user isn't validated here.
    // A better approach involves the frontend calling the mutation first.
    
    // --- TEMPORARY WORKAROUND (Less Secure) ---
    // Ideally, state is generated by a *mutation* called by the *authenticated user*
    // and passed to this endpoint, NOT generated here without auth.
    const url = new URL(request.url);
    const state = url.searchParams.get("state"); // Expect state from frontend redirect
    if (!state) {
        console.error("Missing state parameter in startGoogleOAuth request.");
        return new Response("Missing state parameter", { status: 400 });
    }
    // -------------------------------------

    const authUrl = new URL("https://accounts.google.com/o/oauth2/v2/auth");
    authUrl.searchParams.set("client_id", clientId);
    authUrl.searchParams.set("redirect_uri", redirectUri);
    authUrl.searchParams.set("response_type", "code");
    authUrl.searchParams.set("scope", GOOGLE_SCOPES.join(" "));
    authUrl.searchParams.set("access_type", "offline"); // Request refresh token
    authUrl.searchParams.set("prompt", "consent"); // Force consent screen for refresh token
    // Include the state parameter received from the frontend
    authUrl.searchParams.set("state", state);

    console.log(`Redirecting user to Google OAuth URL with state: ${state}`);
    return new Response(null, { 
        status: 302,
        headers: { Location: authUrl.toString() },
    });
});

// Action to handle the callback from Google after user authorization
const handleGoogleCallback = httpAction(async (ctx, request) => {
    const clientId = getEnvVariable("GOOGLE_CLIENT_ID");
    const clientSecret = getEnvVariable("GOOGLE_CLIENT_SECRET");
    const appUrl = getEnvVariable("APP_URL"); // Your frontend app URL
    const convexSiteUrl = getEnvVariable("PUBLIC_CONVEX_HTTP_URL"); 
    const redirectUri = `${convexSiteUrl}/handleGoogleCallback`;

    const url = new URL(request.url);
    const code = url.searchParams.get("code");
    const error = url.searchParams.get("error");
    const state = url.searchParams.get("state"); // Get state from Google's callback

    if (error) {
        console.error(`Google OAuth Error: ${error}`);
        const errorSettingsUrl = `${appUrl}/settings?error=oauth_error&provider=google&message=${encodeURIComponent(error)}`;
        return new Response(null, { status: 302, headers: { Location: errorSettingsUrl }});
    }
    if (!code) {
        // Handle case where user denies access
        console.warn("Authorization code missing. User likely denied access.");
        const deniedSettingsUrl = `${appUrl}/settings?error=access_denied&provider=google`;
        return new Response(null, { status: 302, headers: { Location: deniedSettingsUrl }});
    }
    if (!state) {
        console.error("State parameter missing from Google callback.");
        const errorSettingsUrl = `${appUrl}/settings?error=missing_state&provider=google`;
        return new Response(null, { status: 302, headers: { Location: errorSettingsUrl }});
    }

    let userId: Id<"users"> | null = null;
    try {
        // --- Validate State and Get User ID --- 
        // This mutation validates the state AND deletes it
        userId = await ctx.runMutation(internal.connections.consumeOAuthState, { 
            stateValue: state 
        });
        console.log(`Successfully validated state ${state} for user ${userId}`);

        // --- Exchange Code for Tokens --- 
        const tokenUrl = "https://oauth2.googleapis.com/token";
        const tokenResponse = await fetch(tokenUrl, {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({
                code: code,
                client_id: clientId,
                client_secret: clientSecret,
                redirect_uri: redirectUri,
                grant_type: "authorization_code",
            }),
        });

        if (!tokenResponse.ok) {
            const errorBody = await tokenResponse.text();
            throw new Error(`Failed to exchange code for token: ${tokenResponse.status} ${errorBody}`);
        }

        const tokenData = await tokenResponse.json();
        const accessToken = tokenData.access_token;
        const refreshToken = tokenData.refresh_token; // Only sent on first authorization
        const grantedScopes = tokenData.scope.split(" ");

        if (!accessToken) {
            throw new Error("Access Token not found in Google response.");
        }
        // IMPORTANT: Handle missing refresh token on subsequent authorizations if needed
        if (!refreshToken) {
             console.warn("Refresh Token not received. User might have already authorized.");
             // TODO: Need a strategy to retrieve/reuse existing refresh token if only updating scopes.
             // This often involves checking existing connections before starting OAuth.
        }

        // --- Get User Info (Email) --- 
        const userInfoUrl = "https://www.googleapis.com/oauth2/v2/userinfo";
        const userInfoResponse = await fetch(userInfoUrl, {
            headers: { Authorization: `Bearer ${accessToken}` },
        });

        if (!userInfoResponse.ok) {
            throw new Error(`Failed to fetch user info: ${userInfoResponse.status}`);
        }
        const userInfo = await userInfoResponse.json();
        const userEmail = userInfo.email;

        if (!userEmail) {
            throw new Error("Could not retrieve email from Google user info.");
        }

        // --- Store Connection in DB (WITH RAW TOKENS - UNSAFE) ---
        console.log(`Storing connection for user ${userId}, email ${userEmail} (Tokens stored UNSAFELY)`);
        await ctx.runMutation(internal.connections.storeOrUpdateGoogleConnection, {
            userId: userId,
            accountEmail: userEmail,
            scopes: grantedScopes,
            // Pass the raw tokens 
            accessToken: accessToken, 
            refreshToken: refreshToken, // Pass even if undefined (optional field)
        });

        // --- Redirect User Back to Frontend (Success) ---
        const settingsUrl = `${appUrl}/settings?success=connection&provider=google`; 
        console.log(`Google OAuth successful for ${userEmail}. Redirecting user ${userId} to ${settingsUrl}`);
        return new Response(null, {
            status: 302,
            headers: { Location: settingsUrl },
        });

    } catch (error: any) {
        console.error("Error in Google OAuth callback:", error);
        // Redirect back to settings with an error parameter
        const errorParam = error.message === "Invalid or expired OAuth state provided." ? "invalid_state" : "oauth_failed";
        const errorSettingsUrl = `${appUrl}/settings?error=${errorParam}&provider=google`;
        return new Response(null, {
            status: 302,
            headers: { Location: errorSettingsUrl },
        });
    }
});

// Define routes
http.route({
    path: "/startGoogleOAuth",
    method: "GET",
    handler: startGoogleOAuth,
});

http.route({
    path: "/handleGoogleCallback",
    method: "GET",
    handler: handleGoogleCallback,
});

// Microsoft routes would be added similarly
// http.route({ path: "/startMicrosoftOAuth", ... });
// http.route({ path: "/handleMicrosoftCallback", ... });

// Mailgun Webhook Endpoint to handle incoming email replies
http.route({
  path: "/emailReplyWebhook",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    // Get Mailgun signature header
    const signatureHeader = request.headers.get('signature');
    if (!signatureHeader) {
      console.warn("Mailgun webhook request missing signature header.");
      return new Response("Missing signature header", { status: 400 });
    }

    let signatureData;
    try {
      signatureData = JSON.parse(signatureHeader);
      if (!signatureData.timestamp || !signatureData.token || !signatureData.signature) {
        throw new Error("Invalid signature header format");
      }
    } catch (e) {
      console.warn("Error parsing Mailgun signature header:", e);
      return new Response("Invalid signature header", { status: 400 });
    }

    const { timestamp, token, signature } = signatureData;

    // Get form data
    let formData;
    try {
      formData = await request.formData();
    } catch (e) {
      console.error("Error parsing form data from Mailgun webhook:", e);
      return new Response("Failed to parse form data", { status: 400 });
    }

    // Extract required fields
    const recipient = formData.get("recipient") as string | null;
    const sender = formData.get("sender") as string | null;
    const bodyPlain = formData.get("stripped-text") as string || formData.get("body-plain") as string | null;
    const messageId = formData.get("Message-Id") as string | null;

    // Basic validation of form fields
    if (!recipient || !sender || !bodyPlain || !messageId) {
      console.warn("Mailgun webhook missing required form fields", { recipient, sender, bodyExists: !!bodyPlain, messageId });
      // Return 200 to prevent Mailgun retries for fundamentally invalid data
      return new Response("Missing required email fields", { status: 200 });
    }

    try {
      // Call the internal action to verify signature and process data
      const result = await ctx.runAction(internal.mailgun.verifyAndProcessWebhook, {
        timestamp,
        token,
        signature,
        recipient,
        sender,
        bodyPlain,
        messageId,
      });

      // Return response based on the action's outcome
      return new Response(result.message, { status: result.status });

    } catch (error: any) {
      console.error("Error invoking verifyAndProcessWebhook action:", error);
      // Generic error if the action itself fails unexpectedly
      return new Response("Internal Server Error invoking action", { status: 500 });
    }
  }),
});

// Export the configured router
export default http;

 